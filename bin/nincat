#!/usr/bin/env python

# Copyright (c) 2012-2014, Somia Reality Oy
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from __future__ import absolute_import, print_function

import argparse
import json
import logging
import select
import sys

from ninchat.client import log
from ninchat.client.adapter import SyncCallbackAdapter, SyncQueueAdapter
from ninchat.client.session.thread import CallbackSession, QueueSession

log.addHandler(logging.StreamHandler())
log.setLevel(logging.INFO)

errors = False

def error(message, error_event):
	global errors
	errors = True

	if error_event.error_reason:
		details = ["(%s)" % error_event.error_reason]
	else:
		details = []

	print("error:", message, error_event.error_type, *details, file=sys.stderr)

def debug(*args):
	print(*args, file=sys.stderr)

def main():
	parser = argparse.ArgumentParser()
	parser.add_argument("-u", "--user", metavar="FILE", default=".nincat",
		help='file for storing credentials (defaults to ".nincat")')
	parser.add_argument("--create-user", metavar="NAME",
		help="create a user account and write login info to FILE")
	parser.add_argument("--delete-user", action="store_true",
		help="delete the user account specified by FILE")
	parser.add_argument("--set-email", metavar="ADDRESS",
		help="make the user permanent (after email verification)")
	parser.add_argument("-j", "--join", action="store_true",
		help="join the specified channels (instead of sending)")
	parser.add_argument("-p", "--part", action="store_true",
		help="part from the specified channels (instead of sending)")
	parser.add_argument("-l", "--listen", action="store_true",
		help="print received messages to stdout until terminated")
	parser.add_argument("channels", metavar="ID", nargs="*",
		help="send lines from stdin to this channel id")
	args = parser.parse_args()

	echo = args.channels and not (args.join or args.part)

	if not (args.create_user or
	        args.set_email or
	        args.join or
	        echo or
	        args.part or
	        args.delete_user or
	        args.listen):
		parser.print_help()
		sys.exit(1)

	session_params = {
		"message_types": ["ninchat.com/text"] if (echo or args.listen) else [],
	}

	if args.create_user:
		session_params["user_attrs"] = {
			"name": args.create_user,
		}
	else:
		with open(args.user) as file:
			session_params["user_id"] = file.readline().strip()
			session_params["user_auth"] = file.readline().strip()

	def on_received(session, event):
		if event.name != "message_received":
			return

		if not args.listen:
			return

		if args.channels and event.channel_id not in args.channels:
			return

		content = json.loads(event.payload[0].decode("utf-8"))
		print("<%s> %s" % (event.message_user_name, content["text"]))

	def on_closed(session):
		pass

	with SyncCallbackAdapter(CallbackSession(on_received, on_closed)) as session:
		event = session.create(**session_params)
		if event.name != "session_created":
			error("create_session:", event)
			sys.exit(2)

		if args.create_user:
			with open(args.user, "w") as file:
				print(event.user_id, file=file)
				print(event.user_auth, file=file)

			debug(event)

		if args.set_email:
			event = session.create_identity(
					identity_type = "email",
					identity_name = args.set_email)
			if event.name == "error":
				error("create_identity:", event)
			else:
				debug(event)

		if args.join:
			for channel_id in args.channels:
				event = session.join_channel(
						channel_id = channel_id)
				if event.name == "error":
					error("join_channel %s:" % channel_id, event)
				else:
					debug(event)

		if echo:
			while True:
				line = sys.stdin.readline()
				if not line:
					break

				for channel_id in args.channels:
					event = session.send_message(
							channel_id   = channel_id,
							message_type = "ninchat.com/text",
							payload      = [json.dumps({ "text": line })])
					if event.name == "error":
						error("send_message %s:" % channel_id, event)

		if args.listen:
			try:
				select.select([], [], [])
			except KeyboardInterrupt:
				pass

		if args.part:
			for channel_id in args.channels:
				event = session.part_channel(
						channel_id = channel_id)
				if event.name == "error":
					error("part_channel %s:" % channel_id, event)
				else:
					debug(event)

		if args.delete_user:
			with open(args.user) as file:
				event = session.delete_user(
						user_auth = file.readlines()[1].strip())
				if event.name == "error":
					error("delete_user:", event)
				else:
					debug(event)

	if errors:
		sys.exit(3)

if __name__ == "__main__":
	try:
		main()
	except KeyboardInterrupt:
		pass
